{"version":3,"file":"index-084c89ed.js","sources":["../../node_modules/@smithy/core/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js","../../node_modules/@smithy/core/node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js","../../node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],"sourcesContent":["export const fromUtf8 = (input) => new TextEncoder().encode(input);\n","export const toUtf8 = (input) => {\n    if (typeof input === \"string\") {\n        return input;\n    }\n    if (typeof input !== \"object\" || typeof input.byteOffset !== \"number\" || typeof input.byteLength !== \"number\") {\n        throw new Error(\"@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.\");\n    }\n    return new TextDecoder(\"utf-8\").decode(input);\n};\n","import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],"names":["fromUtf8","input","toUtf8","EventStreamSerde","marshaller","serializer","deserializer","serdeContext","defaultContentType","__publicField","eventStream","requestSchema","initialRequest","eventStreamMember","unionSchema","initialRequestMarker","eventStreamIterable","headers","body","page","event","unionMember","key","additionalHeaders","eventType","explicitPayloadContentType","response","responseSchema","initialResponseContainer","_a","memberSchemas","initialResponseMarker","asyncIterable","_b","dataObject","eventStreamSchema","out","hasBindings","name","member","eventHeader","eventPayload","value","asyncIterator","firstEvent","done","explicitPayloadMember","isKnownSchema","eventSchema","memberName","memberSchema","type","payloadSchema","messageSerialization"],"mappings":"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","x_google_ignoreList":[0,1,2]}